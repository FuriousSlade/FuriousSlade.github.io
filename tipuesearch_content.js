var tipuesearch = {"pages":[{"url":"https://chihiro.moe/pages/links.html","text":"importcjj python go 小鲜肉 oreki.moe 死宅","tags":"misc","title":"友链"},{"url":"https://chihiro.moe/posts/2018/TailGrepAwk.html","text":"通过 tail, grep, awk 命令组合使用,统计log中关键字出现的次数 tail -f info.log | awk '/关键字/ {++i;printf \"\\r%d\",i}'","tags":"笔记","title":"命令行统计log中关键字出现的次数"},{"url":"https://chihiro.moe/posts/2018/DockerNotes.html","text":"Docker 是什么 Docker 是使用 Google 公司推出的 Go 语言进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。 Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。 Docker 的优势 更高效的利用系统资源 更快的启动时间 一致的运行环境 易部署 易扩展 镜像构建过程透明 Docker 的用途 个人 提供一次性，一致性的环境，用于测试或是构建 代替虚拟机在一台机器上搭建多个微服务 Docker 基本概念 镜像 Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 容器 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库 镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。 macOS 安装 Docker https://docs.docker.com/docker-for-mac/install/ 常用命令 # 拉取镜像 docker pull # 查看本地镜像 docker images # 查看容器 docker ps # 删除本地镜像 docker image rm # 启动容器 docker run # 清理所有处于终止状态的容器 docker container prune Demo 拉取ubuntu镜像 寻找 docker images 上 docker hub docker pull ubuntu:14.04 14.04: Pulling from library/ubuntu 99ad4e3ced4d: Pull complete ec5a723f4e2a: Pull complete 2a175e11567c: Pull complete 8d26426e95e0: Pull complete 46e451596b7c: Pull complete Digest: sha256:ed49036f63459d6e5ed6c0f238f5e94c3a0c70d24727c793c48fded60f70aa96 Status: Downloaded newer image for ubuntu:14.04 查看本地镜像 docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 14.04 a35e70164dfb 12 days ago 222MB 构建镜像 Docker commit 黑箱镜像，不常用，不推荐。 Docker file touch Dockerfile FROM ubuntu:14.04 RUN apt-get update \\ && apt-get install -y python \\ && apt-get install -y python-pip \\ && pip install flask COPY ./hello.py /app/ CMD [\"python\", \"/app/hello.py\"] from flask import Flask app = Flask ( __name__ ) @app.route ( '/' ) def hello_world (): return 'Hello docker!' if __name__ == '__main__' : app . run ( host = '0.0.0.0' ) docker build -t demo:v1 ./ 启动容器 docker run -p 5000:5000 demo:v1 参考文献 Docker — 从入门到实践","tags":"笔记","title":"Docker学习笔记"},{"url":"https://chihiro.moe/posts/2018/Ac68uMerlin.html","text":"自动挂载U盘至/opt cat << EOF > /tmp/script_usbmount.tmp if [ \\$1 = \"/tmp/mnt/sda\" ] then ln -sf \\$1 /tmp/opt /opt/etc/init.d/rc.unslung start fi EOF nvram set script_usbmount=\"`cat /tmp/script_usbmount.tmp`\" cat << EOF > /tmp/script_usbumount.tmp if [ \\$1 = \"/tmp/mnt/sda\" ] then /opt/etc/init.d/rc.unslung stop fi EOF nvram set script_usbumount=\"`cat /tmp/script_usbumount.tmp`\" nvram commit reboot 安装 Entware 较新版本的merlin系统已自带entware安装脚本 entware-setup.sh # 更新仓库索引 opkg update # 安装软件 opkg install {package}","tags":"笔记","title":"AC68U折腾笔记"},{"url":"https://chihiro.moe/posts/2018/CrontabBadHourError.html","text":"crontab -e # bug */10 23-06 * * * echo hello # right */10 23,00-06 * * * echo hello","tags":"笔记","title":"Crontab bad hour error"},{"url":"https://chihiro.moe/posts/2018/CurlNoProxy.html","text":"被系统全局http代理折腾了一把 curl -X POST \\ http://ip:port/rpc \\ -d '{ \"hello\": \"world\" }' --noproxy \"*\"","tags":"笔记","title":"Curl 不使用代理"},{"url":"https://chihiro.moe/posts/2018/LearnPython3.html","text":"简述 Life is short, you need Python. Shut up and show me the code. 基础语法 编码 Python 3 源码文件默认以 UTF-8 编码。也可以自行指定。 # -*- coding: <encoding_name> -*- encoding_name 为 pyhton 支持的有效 编码 例如： # -*- coding: gb2312 -*- 或 # -*- coding: cp-1252 -*- 关键字 import keyword keyword . kwlist ['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 注释 # 单行注释 ''' 多行 注释 ''' \"\"\" 还是 多行 注释 \"\"\" 行与缩进 Python最具特色的就是使用缩进来表示代码块。 行缩进使用4个空格，或将tab调整为4个空格。 #!/usr/bin/env python # -*- coding: utf-8 -*- class Year ( object ): def __init__ ( self ): self . do_better () def do_better ( self , day = 1 ): if day < 365 : day += 1 self . do_better ( day ) if __name__ == '__main__' : new_year = Year () 多行语句 game_machines = 'PS4,' + \\ 'Xbox,' + \\ 'Nintendo Switch' print ( game_machines ) PS4,Xbox,Nintendo Switch game_machines = [ 'PS4' , 'Xbox' , 'Nintendo Switch' ] print ( game_machines ) ['PS4', 'Xbox', 'Nintendo Switch'] 数据类型 内置对象 数字 字符串 列表 字典 元组 集合 文件 None 布尔型 ... 数字 # int 整数型 1 + 2 3 # float 浮点型 1.5 * 3 4.5 # float 浮点型 3.14159 * 3 # 浮点计算会存在精度问题需要特别处理 9.424769999999999 字符串 字符串格式化 version >= 3.6 msg = 'world!' print ( f 'hello {msg}' ) hello world! d = { 'a' : 1 , 'b' : 3.1415927 } print ( f 'a = {d[\"a\"]}' ) print ( f 'b = {d[\"b\"]}' ) print ( f 'b = {d[\"b\"]:.2f}' ) print ( f 'a + b = {d[\"a\"] + d[\"b\"]:.2f}' ) a = 1 b = 3.1415927 b = 3.14 a + b = 4.14 f 'mapping is { {a:b for (a, b) in ((1, 2), (3, 4))} }' 'mapping is {1: 2, 3: 4}' 赋值、浅拷贝、深拷贝 坑过 import copy a = [ \"空银子\" , { \"age\" : 15 }] # 赋值 b = a # 浅拷贝 c = a . copy () # 深拷贝 d = copy . deepcopy ( a ) print ( f 'a is {a}, id is {id(a)}' ) print ( '-' * 35 ) print ( f 'b is {b}, id is {id(b)}' ) print ( f 'c is {c}, id is {id(c)}' ) print ( f 'd is {d}, id is {id(d)} \\r\\n ' ) print ( f 'a[1] is {a[1]}, id is {id(a[1])}' ) print ( '-' * 35 ) print ( f 'b[1] is {b[1]}, id is {id(b[1])}' ) print ( f 'c[1] is {c[1]}, id is {id(c[1])}' ) print ( f 'd[1] is {d[1]}, id is {id(d[1])} \\r\\n ' ) print ( 'Changed a: a[0] = \"雏鹤爱\", a[1][\"age\"] = 9 \\r\\n ' ) a [ 0 ] = \"雏鹤爱\" a [ 1 ][ \"age\" ] = 9 print ( f 'a is {a}, id is {id(a)}' ) print ( '-' * 35 ) print ( f 'b is {b}, id is {id(b)}' ) print ( f 'c is {c}, id is {id(c)}' ) print ( f 'd is {d}, id is {id(d)} \\r\\n ' ) print ( f 'a[1] is {a[1]}, id is {id(a[1])}' ) print ( '-' * 35 ) print ( f 'b[1] is {b[1]}, id is {id(b[1])}' ) print ( f 'c[1] is {c[1]}, id is {id(c[1])}' ) print ( f 'd[1] is {d[1]}, id is {id(d[1])}' ) a is ['空银子', {'age': 15}], id is 4415182472 ----------------------------------- b is ['空银子', {'age': 15}], id is 4415182472 c is ['空银子', {'age': 15}], id is 4415182408 d is ['空银子', {'age': 15}], id is 4415184200 a[1] is {'age': 15}, id is 4413290608 ----------------------------------- b[1] is {'age': 15}, id is 4413290608 c[1] is {'age': 15}, id is 4413290608 d[1] is {'age': 15}, id is 4414213144 Changed a: a[0] = \"雏鹤爱\", a[1][\"age\"] = 9 a is ['雏鹤爱', {'age': 9}], id is 4415182472 ----------------------------------- b is ['雏鹤爱', {'age': 9}], id is 4415182472 c is ['空银子', {'age': 9}], id is 4415182408 d is ['空银子', {'age': 15}], id is 4415184200 a[1] is {'age': 9}, id is 4413290608 ----------------------------------- b[1] is {'age': 9}, id is 4413290608 c[1] is {'age': 9}, id is 4413290608 d[1] is {'age': 15}, id is 4414213144 To be continued ...","tags":"笔记","title":"Python3学习笔记"},{"url":"https://chihiro.moe/posts/2018/BaiduSpiderAndGHPages.html","text":"某天突然发现无法百度到自己的博客内容了，于是乎开始一段曲折的排障过程。 我的blog是放在GitHub pages，并通过cloudflare搞了一个伪https，并且使用了cloudflare的cdn服务。 通过各种搜百度，搜谷歌，站长工具debug。确认了是GitHub屏蔽了百度的爬虫。GG 参考了 知乎 上的几个解决方案： 使用CDN Dnspod 双路解析 更换pages服务商 我原本就使用了cdn服务依然出现爬虫失败的问题，分析下来一个是流量本身太小（是根本没有好吗），造成请求很容易回源，然后403。 Dnspod 双路解析的话就无法使用cloudflare提供的伪https了，瞬间逼格就下来了。 最终我选择了更换pages服务提供者。 Coding的pages服务，5秒广告，谢谢不送。 GitCafe被Coding收购了 GG。 又看了下Gitee（码云）的pages服务，不支持自定义域名，不符合需求。 GitLab的pages服务完全符合需求 nice，开搞。 原本blog使用的python的pelican框架代码在GitHub上并通过Travis-ci进行构建的，并不是本地构建后推送到远端的，主要是因为懒，这样只需要写Markdown文件，提交，持续集成，持续发布。所以又想了一个懒办法。在Travis-ci进行构建GitHub pages的同时把代码提交到GitLab仓库，再由GitLab的CI/CD进行持续集成构建。 GitLab提供的pages服务使用姿势和GitHub还是有很大不同的。 GitLab pages搭建官方说明 简单来说就是需要见一个项目，且项目名必须是 {username}.gitlab.io 并在项目下建立GitLab Ci所用配置文件 .gitlab-ci.yml 以我使用的python pelican blog生成器举例 .gitlab-ci.yml： image : python : 2.7 - alpine before_script : - apk update && apk upgrade && apk add git pages : script : - pip install - r requirements . txt - git clone -- depth 1 https :// github . com /FuriousSlade/ pelican - swain . git - git clone -- depth 1 https :// github . com /FuriousSlade/ pelican - plugins . git - pelican - s publishconf . py - mv output public artifacts : paths : - public / 详解： # 构建使用的docker镜像 image: python:2.7-alpine # 构建前执行脚本 # 因为需要git clone 依赖的模版和插件，构建前先安装git（基础镜像无git命令） before_script: - apk update && apk upgrade && apk add git # 构建pages pages: script: # pip安装依赖库 - pip install -r requirements.txt # git clone 依赖模版 - git clone --depth 1 https://github.com/FuriousSlade/pelican-swain.git # git clone 依赖插件 - git clone --depth 1 https://github.com/FuriousSlade/pelican-plugins.git # 构建静态blog - pelican -s publishconf.py # 将构建结果目录output重命名为public，注意静态资源的输出目录必须是public - mv output public artifacts: paths: # 最终将会发布到pages的目录 # 本来我改了目录为output最终导致pages 404 # 只有使用public时pages服务正常可用，不知道是不是潜规则 - public/ 确定GitLab能正确触发构建，生成pages页面。 变更域名解析至GitLab pages（也可以作为Dnspod双路解析Coding的替代）。 最终代码依然提交GitHub，利用GitLab提供pages服务。 实际使用GitLab CI服务后发现构建job经常等待，不如Travis-ci及时，可惜可惜。","tags":"Blog","title":"解决百度爬虫无法爬取Github Pages上的个人博客"},{"url":"https://chihiro.moe/posts/2017/WantToDo.html","text":"To do 老师！ 《老师！》是由三木孝浩指导，生田斗真、广濑铃主演的真人版漫改电影。影片将于2017年秋季在日本上映。《老师！》根据河原和音创作的师生纯爱漫画改编。 声之形-漫画 看了电影，再看看漫画吧。 Done 刀剑神域2 看完想入游戏了，不过刀剑神域几部游戏反响都不高。 来自深渊 萌萌的娜娜奇。 画面美到窒息，故事致郁无比。 刀剑神域：序列之争 错过电影了，讨厌加班。 纽约唯一活着的男孩 故事讲述充满文青气质的汤马大学毕业，从父亲的豪宅搬到小区生活，漂流在纽约大都会中，一日，汤马意外发现父亲有外遇，试图出手阻止但却情不自禁投入外遇的怀抱。汤马迷失在了偷情的快感与罪疚之中. 声之形 西宫硝子（早见沙织 饰）生来患有听觉障碍，要依靠助听器和外界交流，口语发音也因此格外的古怪。初中时，硝子转入了一所新的学校，特殊的生理缺陷让她成为了班上引人注目的独特存在，她因此收获了坚实的友情，却也遭到了以男生石田将也（入野自由 配音）为首的小团体的孤立和排挤。随着时间的推移，无心或有意的恶作剧渐渐升级，最终演变成为了无法挽回的伤害，硝子永远的消失在了众人的眼前。 排挤硝子的事情曝光后，将也成为了下一个被欺负的对象，孤独痛苦的他终于理解了硝子的隐忍和温柔，只是他再也没有机会跟硝子道歉了。一次偶然中，将也同硝子重逢了，命运的齿轮重新开始了转动。","tags":"Blog","title":"想看和已看"},{"url":"https://chihiro.moe/posts/2017/GetF460Admin.html","text":"浏览器访问 http://192.168.1.1/manager_dev_config_t.gch 可下载光猫配置文件。 使用offzip解压config.bin可得到多个dat文件，用文本编辑器打开000000d8.dat。 搜索telecomadmin。","tags":"笔记","title":"中兴光猫F460管理员账号破解"},{"url":"https://chihiro.moe/posts/2017/ForHonor.html","text":"入坑PS4荣耀战魂，Ubisoft的为PS4准备的土豆服务器还算可以，电信裸连，折腾了一下AC68U后NAT OPEN的情况下玩的还算舒爽。就是大佬太多，天天被按在地板上摩擦。(╥﹏╥)","tags":"Blog","title":"荣耀战魂，手残党，痛并快乐着。"},{"url":"https://chihiro.moe/posts/2017/RabbitMQBasis.html","text":"RabbitMQ简介 RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、PHP等，支持AJAX。用于在分布式系统中存储转发消息。 AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。 关键字 Producer Producer(生产者),投递消息的程序。 Consumer Consumer(消费者),接受消息的程序。 Exchange Exchange(交换机)，它指定消息按什么规则，路由到哪个队列 Queue Queue(队列)是RabbitMQ的内部对象，用于存储消息. Durable Durable(持久化)，队列消息的持久化。 Binding Binding(绑定)，它的作用就是把exchange和queue按照路由规则绑定起来。 Routing Key Routing Key(路由关键字)，exchange根据这个关键字进行消息投递。 Vhost Vhost(虚拟主机),一个服务实例里可以开设多个vhost，用作不同用户的权限分离。 Exchange Types Fanout Fanout类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。 Direct Direct类型的Exchange路由规则也很简单，它会把消息路由到那些binding key与routing key完全匹配的Queue中。 Topic Topic类型的Exchange路由规则也很简单，它会把消息路由到那些binding key与routing key进行模糊匹配，然后发送到相应的Queue中。","tags":"笔记","title":"RabbitMQ基础概念"},{"url":"https://chihiro.moe/posts/2017/GithubTravis-ciCoding.html","text":"原文链接： https://oreki.moe/... 原文： ---Start--- 这个和一般的博客有什么区别 可以在任何地方在Github上写下Markdown语法的内容，然后就会自动编译成html并发布 可以绑定自己的域名 可以比较自由地改样式 和别人家的不太一样，可以装逼 静态页面打开比较快 可以分国内外进入不同服务器，打开比较快，~~异地多活~~ 不要钱，不要钱，不要钱 demo地址 当然就是我的博客啦。。 Github上的地址是： 戳我 准备工作 建一个Github账号，如果没有的话 建一个Travis-ci账号，并与Github绑定，如果没有的话 安装travis的cli命令行工具（ sudo gem install travis ） 建一个Coding账号，如果没有的话（可选） 保证自己有Python, pip等工具（可选） 准备一个域名（可选） 让我们开始吧 因为我的博客用了 pelican ，所以我就用他作为教程的一部分了。。如果你喜欢 hexo 之类的，只要替换掉这个部分的内容就行了。 第一步，本地安装pelican并且完成配置 一般来说，只要 pip install pelican markdown 就能搞定了。。 如果不行的话，就 戳我 来看官方的安装文档吧。。 然后就依次执行 mkdir -p ~/projects/yoursite cd ~/projects/yoursite pelican-quickstart 注意把对应的目录名字改掉。。。 然后就会有一个亲切的人机互动界面，你可以按照他的提示，把必要的信息填进去，填错也没关系，之后可以改 然后你的目录大概看上去长这样 . ├── Makefile ├── content ├── develop_server.sh ├── fabfile.py ├── output ├── pelicanconf.py └── publishconf.py 然后，你可以在content文件夹内，加入你的第一篇博客，你可以这么写 Title: 呵呵 Date: 2016-03-18 18:28:12 Category: HEHE 大家好我是博客主体内容。:) 然后保存为 hello_world.md 就行了。。 再之后，你只要做 pelican content 就可以build出html页面并输出到 ./output 下。 你可以通过进入output目录，再使用pelican自带的服务器启动预览 python -m pelican.server 来看看成果吧。进入 http://localhost:8000 来访问。 接下来你可以对你的博客进行各个角度的调整，例如增加插件啊，更换模板啊，更改名字啊等等。。 第二步 将源码push至Github 看到这里的时候，你需要保证你的博客已经能够顺利地build了 现在，我们需要在Github上增加一个public的repo来储存你的博客的源码。 创建repo的话， 戳这里 之后就将你刚才创建的源码加入git版本控制中 cd /path/to/your/blog/directory git init git remote add origin git@github.com:your_name/your_repo.git git push origin master 如果一切顺利，你的代码就被push到github上托管了。 顺带一提的是，你的 output 文件夹内的内容其实是build生成的，应该被排除在版本控制之外。 所以可以在 .gitignore 这个文件中添加 output/ 来将整个文件夹去除。 第三步 开启github pages Github Pages是Github的一个静态页面托管的服务。你可以将静态的html放在git的 gh-pages 分支。 在push至github之后，他就会自动地将该分支内的内容发布至互联网上。 这一步其实非常简单，我们使用一个插件来帮助我们完成这个动作。 这个插件的名字叫 ghp-import 可以通过pip来安装 pip install ghp-import 使用的话也很简单，只需要一行命令 ghp - import - n output / 这行命令会创建gh-pages分支，并填充指定的文件夹下的内容。 再之后我们只需要push该分支至github就行 git checkout gh-pages git push origin gh-pages 然后，你就可以通过 http://your_name.github.io/your_repo 来访问你的博客了。 关于怎么使用自己的域名，可以 戳这里 第四步 使用travis-ci来构建博客 其实做到第三步，理论上你已经可以完整地使用你的博客了。 但是，每次都要在cli下执行一坨命令来build博客再上传是不是很麻烦呢，而且也不支持在线编辑。 所以我们需要一个第三方的平台来帮我们构建自己的博客。 在这种情况下，提供开源免费服务的travis-ci就是首选了。 核心的思路就是，每当任何代码被push至blog的master分支后，travis-ci帮我去做build以及push至对应repo的动作。 那问题就来了，怎么让travis-ci拥有权限push代码到我的repo中呢？ 在这里，我们需要使用github的一个功能叫做person_access_token 可以通过 戳这里 来添加token。 只需要勾选public_repo的权限就可以了。。 之后在Makefile中添加了github的方法以及在项目根目录中添加 .travis.yml 文件，来让travis-ci能够识别并正确执行build流程 Makefile 添加： github : publish ifeq ( $ ( TRAVIS_PULL_REQUEST ), false ) ghp - import - n $ ( OUTPUTDIR ) @git push - fq https : // $ { GH_TOKEN } @github.com / $ ( TRAVIS_REPO_SLUG ) . git gh - pages > / dev / null endif . travis . yml 文件添加： language : python branches : only : - master install : - pip install pelican - pip install markdown - pip install ghp - import script : - 'make github 2> /dev/null' env : global : - GH_TOKEN : 9 c898c9b98a877663e4a556989b 但是，如果这样做的话，你的person_access_token就会被放进代码库中，会被任何人获取到，存在安全隐患。 所以我们需要对它进行加密。。 还好travis-ci预料到了这样的需求发生，它允许你拥有一些不能被别人知道的变量。 你可以通过命令来创建它 cd /path/to/your/repo travis encrypt GH_TOKEN=9c898c9b98a877663e4a556989b 之后travis会给你一长串字符串，这个字符串是通过RSA加密过的，private key是保存在travis服务器上，普通人只能拿到public key，所以相对还是比较安全的。 然后，我们把这个key加入 .travis.yml 中 env : global : - secure : xUPoc + miOMcmsgKu2kpQM5Sl5pRxN1HaNoXK20Iog4ynVo0DRA9gBkvS8Q /H15+ddDqu+fNMblCw2jIbXtUQmaciS1e+Gx1+vtBnD8f2i9JFwwo8P8sdTRX6ucvQuZBRssmrId6qY6qsz+iTri+kG1P5wzNasvMWpvPWgexK7enhDeoaGPeDwLT6KLZmXdsIuGCM1X7kGnVhMYi8pom0dDN4HFYrtzp/PidYFA3xsAOjyjqfgeMdZ1Oxot3281ilvAvY8DDhJ3ZNhkiNFBFAYN2MmQxOLQj4d15puJ8tAr4bKLmxOJkHBP0CE621bDZcLkTkk82TtgJyq3KZWv503ni6LFQ0qmJGEICSYfP/5lWKF/6BQzTBjOoeKCunZKqP1KVgUkXDgAqwo8yv+f3ZTOxD0xoysOnnE+q8QBWlxojWRFx01Ihg/G1kYpIgm+HXzY4huqIXST3Vu1Me4UISeGX/lSXeJ3/kjbCqNRMdeybag7nLSrKudnr/A+6R4gbQFOks6FjEl7HWCX/jSGcNSupIJCd+dhYlsz0KxhYxIuWDmRphGS0mM4z58T71GdL0YNZ40q8NG7fSGGF2j++u8KqtvLIXSj6RpIE6I3qum7iJkZhYEBAFpzQjlT6lfHZg13PTZljk+juW/zm2kDYat5U/10djOUru1jQ/ B256xaI = 记得删除之前的GH_TOKEN。。。 然后 git push origin master ，并在travis中完成设置，你的博客就可以由travis来build啦。。 第五步 使用Coding为国内分流 因为Coding在国内也提供相类似的服务，并且在国内拥有比较好的访问速度。 所以我们在push build完的html的时候，可以同时push至两个地方（github以及coding）。 再通过dnspod来区分国内外的流量来做分流。 push至coding的方法与github比较相似，在这里就不展开了。如果有问题可以看我blog的repo来参考。。 总结 我已经写的很详细了。。好累啊 ---End---","tags":"Blog","title":"【转】手把手教你如何滥用Github, Travis-ci, Coding等资源来建立一个博客"},{"url":"https://chihiro.moe/posts/2017/MeBeforeYou.html","text":"《Me before you》新年看的第一部电影。 本来是冲着龙妈去的，虽然大致已被剧透，但还是被剧情触动到了。（//▽//） 之前在网上看影评从爱情、社会阶级、已经延伸到安乐死是否该被合法的高度了，感悟是千人千面的。 生活就该活得精采充实。 爱情是美妙的，但爱情不是生活的全部。 黄老板的《Photograph》作为插曲也是相得益彰。 You are pretty much the only thing that makes mewant to get up in the morning. 你​是我每天早上起床的唯一动力。 have become a whole new person because of you. 因为你，我焕然一新。 I don't want you to miss allthe things someone else could give you. 我不想要你错过那些能够好好照顾你的人。 Live boldly. Push yourself. Don't settle. 勇敢面对人生，突破自己，别轻言放弃。 You're going to feel uncomfortablein your new world for a bit. It always does feel strange to be knocked out ofyour comfort zone. 当你脱离舒适圈、面对崭新的世界时，你会觉得不太自在。 All I can say is that you make me……You make me into someone Icouldn't even imagine. You make me happy. 我只能说…我因你而蜕变成前所未料的样子，你让我幸福。 I will never, ever regret the things I've done. Because most days,all you have are places in your memory that you can go to. 我永远不会后悔曾做过的每件事，因为它将永存在我往后的回忆里，历久弥新、永不凋零。 You only get one life. It's actually your duty to live it as fullyas possible. 生命不重来，你的义务就是竭尽所能地活得精采充实。 Some mistakes… Just have greater consequences than others. But youdon't have to let the result of one mistake be the thing that defines you. 有些错误代价高昂，但别被区区一个过失定义了自己。 Don't think of me too often. I don't want to think of you gettingall maudlin. Just live well. Just live. 别经常想我，我不希望你伤感。要好好的…好好的活下去。","tags":"Blog","title":"Me before you"},{"url":"https://chihiro.moe/posts/2017/UpdateBlogHttps.html","text":"博客模版改版,做了一波减法，清爽多了。 通过cloudflare成功https。( ´▽` )ﾉ 使用Pelican插件always_modified给所有的文章默认加上修改时间。 修改index.html模版: {% set paginator_articles = articles | sort ( reverse = True , attribute = 'modified' ) %} {% set offset = ( articles_page.number - 1 ) * DEFAULT_PAGINATION %} {% set end = DEFAULT_PAGINATION * articles_page.number %} {% if end >= paginator_articles | length %} {% set end = paginator_articles | length + 1 %} {% endif %} {% for article in paginator_articles [ offset : end ] %} ... {% endfor %} 修改发布配置文件： PLUGINS = [ 'sitemap', 'gzip_cache', 'extract_toc', 'tipue_search', 'related_posts', 'always_modified', ] ALWAYS_MODIFIED = True 一开始因为没有增加 ALWAYS_MODIFIED = True 这行配置造成在travis ci构建一直失败。 _(´ཀ`」 ∠)_ 实现根据修改时间排序，并可分页。","tags":"Blog","title":"Blog改版"},{"url":"https://chihiro.moe/posts/2017/NewYear2017.html","text":"#!/usr/bin/env python # -*- coding: utf-8 -*- class Year ( object ): def __init__ ( self ): self . do_better () def do_better ( self , day = 1 ): if day < 365 : day += 1 self . do_better ( day ) if __name__ == '__main__' : new_year = Year ()","tags":"Blog","title":"new_year.py"},{"url":"https://chihiro.moe/posts/2016/CookBook.html","text":"耳光炒饭 备料：大头虾、胡萝卜丁、豌豆、咸鸭蛋、隔夜饭。 虾头备用，虾肉下沸水锅加少许盐煮至七成熟。 将咸蛋的蛋黄蛋白分开捣碎。 热锅冷油下虾头炼油，当锅内油呈金黄色后，弃虾头。 虾油锅中下咸蛋黄略炒，入胡萝卜丁、豌豆、和隔夜饭翻炒至米粒均匀上色。放入咸蛋白、虾仁、鸡蛋液继续翻炒均匀。 完成！ 烤茄子 备料：茄子、肉末、蒜泥、葱、豆瓣酱。 热锅冷油，入蒜泥、肉末、豆瓣酱、生抽、味淋、葱花翻炒制成肉酱。 茄子入烤箱190度20分钟后，取出对半剖开，铺入肉酱，再次入烤箱180度烤3分钟。 拿出撒葱花，完成！","tags":"笔记","title":"CookBook。"},{"url":"https://chihiro.moe/posts/2016/Mysql_transaction.html","text":"事务隔离 SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。 Read Uncommitted (读取未提交内容) 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。 Read Committed (读取提交内容) 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。 Repeatable Read（可重读） 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的\"幻影\" 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。 Serializable（可串行化） 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。 优缺点 这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如： 脏读(Drity Read)： 某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。 不可重复读(Non-repeatable read): 在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。 幻读(Phantom Read): 在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。 在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示： 隔离级别 脏读 不可重复读 幻读 Read Uncommitted (读取未提交内容) Y Y Y Read Committed (读取提交内容) N Y Y Repeatable Read(可重读) N N Y Serializable（可串行化) N N N 修改事务隔离级别 SELECT @@global.tx_isolation; SELECT @@session.tx_isolation; SELECT @@tx_isolation; SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE} 如果选择global，意思是此语句将应用于之后的所有session，而当前已经存在的session不受影响。 如果选择session，意思是此语句将应用于当前session内之后的所有事务。 如果什么都不写，意思是此语句将应用于当前session内的下一个还未开始的事务。","tags":"笔记","title":"Mysql事务隔离。"},{"url":"https://chihiro.moe/posts/2016/pelican_swain.html","text":"Pelican-Swain No zuo no die, why you try ? You zuo you die, don't ask me why. 模板用别人的总是不太爽，还是自己作死写一个吧。 基本完成，总算是用上了自己的模板。大量抄袭了 Elegant ，Elegant是我用过功能最全面的Pelican theme了。 简介 使用了bootstrap3、fontawesome，评论使用disqus,站内搜索使用了tipuesearch。社交信息对QQ和微信做了处理：点击展示对应的二维码。 Live demo FuriouesSlade 注意事项 Swain/static/images/ 目录下存放了头像、favicon.ico、QQ和微信的二维码图片。使用时请自行更换。 Config demo # -*- coding: utf-8 -*- # from __future__ import unicode_literals AUTHOR = '' SITENAME = '' SITEURL = '' TIMEZONE = \"Asia/Shanghai\" DEFAULT_DATE_FORMAT = \"%Y-%m- %d \" ARTICLE_URL = 'posts/{date:%Y}/{slug}.html' ARTICLE_SAVE_AS = 'posts/{date:%Y}/{slug}.html' PAGE_URL = 'pages/{slug}' PAGE_SAVE_AS = 'pages/{slug}.html' CATEGORY_URL = 'category/{slug}' CATEGORY_SAVE_AS = 'category/{slug}.html' TAG_URL = 'tag/{slug}.html' TAG_SAVE_AS = 'tag/{slug}.html' DISPLAY_CATEGORIES_ON_SIDEBAR = True LOAD_CONTENT_CACHE = False PATH = u 'content' BANNER_ALL_PAGES = True DEFAULT_LANG = u 'zh' FILENAME_METADATA = \"(?P<slug>.*)\" # Feed generation is usually not desired when developing FEED_ALL_ATOM = None CATEGORY_FEED_ATOM = None TRANSLATION_FEED_ATOM = None AUTHOR_FEED_ATOM = None AUTHOR_FEED_RSS = None # Blogroll LINKS = (( 'Pelican' , 'http://getpelican.com/' ), ( 'Python.org' , 'http://python.org/' ), ( 'Jinja2' , 'http://jinja.pocoo.org/' ),) # Theme THEME = 'pelican-swain' DIRECT_TEMPLATES = ( ( 'index' , 'tags' , 'categories' , 'archives' , '404' , 'search' )) RECENT_ARTICLES_COUNT = 10 SOCIAL = (( 'email' , 'mailto:175439093@qq.com' ), ( 'weibo' , 'http://weibo.com/slade86' ), ( 'github' , 'https://github.com/FuriousSlade' ), ( 'qq' , '175439093' ), ( 'weixin' , 'w12046' ), ) # projects PROJECTS = [{ 'name' : 'Swain' , 'url' : 'https://github.com/FuriousSlade/Swain' , 'description' : 'Pelican Theme' }] MD_EXTENSIONS = ([ 'codehilite(css_class=highlight)' , 'extra' , 'toc' ]) ABOUT_ME = 'I am html' DEFAULT_PAGINATION = 10 USE_FOLDER_AS_CATEGORY = False # plugin config PLUGIN_PATHS = [ u './pelican-plugins' ] PLUGINS = [ 'sitemap' , 'gzip_cache' , 'extract_toc' , 'tipue_search' , 'related_posts' , ] # relate_posts RELATED_POSTS_MAX = 3 # sitemap SITEMAP = { \"format\" : \"xml\" , \"priorities\" : { \"articles\" : 0.7 , \"indexes\" : 0.5 , \"pages\" : 0.3 , }, \"changefreqs\" : { \"articles\" : \"monthly\" , \"indexes\" : \"daily\" , \"pages\" : \"monthly\" , } } # disqus DISQUS_SITENAME = '' Screenshot","tags":"Blog","title":"用上了自己的模板pelican-swain。"},{"url":"https://chihiro.moe/posts/2016/charles_https.html","text":"APP在实际生产环境的部分追求安全性的接口都是https的。抓包工具一般情况下是无法抓取显示https接口调用内容的。这对一些线上问题的追踪产生了一定的障碍。 我一直在mac下使用Charles这个软件来进行抓包分析。Charles本身就是支持抓取https请求的。在一番折腾后成功抓取了https请求。 在此记录下过程： 首先你需要安装Charles，可以从它的官网下载 Charles 。 下载所需要使用到的 证书 . Version of Charles prior to v3.10 used a single SSL Root Certificate. You can still download the legacy certificate bundle here or the certificate itself here (for installing on mobile devices). Note that these certificates will not work on Charles v3.10. 在两个 here 处可以分别下载证书的压缩版本和可直接安装版本。 建议下载直接安装的证书到手机后，我使用的Android手机，进入\"设置\"-->\"安全\"-->\"从SD卡安装证书\"，找到下载好的证书并导入。 然后打开Charles进入Proxy-->SSL Proxying Settings中勾选Enable SSL Proxying,并添加需要抓取的的域名和端口（443）。 然后手机设置代理指向Mac，就可以开始抓取https请求了。 然而 (╯‵ □′ )╯︵┻━┻ 我高兴的太早了。。。并不是所有的APP发出的HTTPS请求都能被正确的抓取到。Charles抓取HTTPS使用的是 代理中间人攻击 方法，是可以有效的被防御的。 中间人攻击（Man-in-the-MiddleAttack，简称\"MITM攻击\"）是一种\"间接\"的入侵攻击，这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信计算机之间，这台计算机就称为\"中间人\"。 只要客户端在SSL协议握手时对服务器返回的证书做校验，伪造的证书就会被识别出来就GG了。 能抓到https请求的，说明APP就是 有BUG_(:з」∠)_ 有BUG_(:з」∠)_ 有BUG_(:з」∠)_ Charles抓取HTTPS请求的结果最终并不理想，但至少HTTPS请求是否会被中间人攻击也能作为一个测试点去关注。","tags":"Blog","title":"在Mac下使用抓包工具Charles抓取APP的Https请求。"},{"url":"https://chihiro.moe/posts/2016/2015_bug_prologue.html","text":"序 自从来到扎拉斯后工作中挖了不少坑也填了不少坑。在新的一年开始时，在此做下记录。 一次正常的请求，生产服务器上确实同时收到了多个请求。 在定位一个运营反馈的线上问题时，发现数据库中落下了两条除了主键ID外完全一样的数据。让开发查看日志后确实发现服务器的一个节点在同一个时间收到了多个相同的请求。因为这个接口本身是一个极低访问量的接口。当初程序设计时为了预留扩张功能，数据库并没有做唯一性索引。也并未加数据库锁表操作（锁表风险太大）\u0010，只是从程序逻辑上做了唯一性的限制\u0010。可以确定用户实际使用中确实只请求了一次，可能是因为网络抖动问题。造成服务器确实同时收到了相同的请求并成功落库。 因为该接口是一个低访问量的接口，最后为了在有预留可扩张功能的，又不锁表的前提下。使用了redis锁。通过redis来达到数据库操作锁的功能，来保证代码的逻辑上的唯一性限制能被正确的触发。而不会因为异常的并发问题造成数据异常。 分布式服务的定时任务造成了并发问题。 在生产环境上有一个job每天会定时去update数据，却发现部分数据被double了。在测试环境上这个功能是完全没有问题的，跑的很正确。因为是分布式服务，生产环境是集群服务造成了定时的job同时也跑了多个。同时去update数据，造成了部分数据被double了。因为读取数据库时间差的原因还有一定的运气因素也只是部分数据被double。不幸中的万幸。 从单个服务器来说这个job都是正确的，最终是依赖redis的分布式锁。来保证只有一台服务器的job会被正确执行。其他服务器的job在得知已有服务器在执行job后，会忽略该次job。 分布式服务同时收到大量的错误请求。 一次收到监控系统预警报告服务器收到大量的500请求。我们后续查看的服务器的日志发现几台通过nginx负载的服务器收到了大量的且相同的请求。这个请求是个异常请求，服务端也正确的捕获了异常，并根据接口约定，返回了相应的500错误。从程序逻辑上来说并没有问题。但诡异的是同一时间段所有负载机都收到了大量的会造成500错误的请求。触发了监控系统发出了警报。 之后跪了一发运维大哥。才知道运维大哥 \"新\" 配置了nginx的重试机制。当一台服务器请求失败后（500了），会向其他的负载机重试该次请求。结果就造成了，我们的服务器同时收到大量的会造成500的请求。nginx本来这个重试机制是一种容错手段。但却与我们的服务设计是冲突的。最后让运维大哥去掉该配置，皆大欢喜。 在测试环境测试通过的服务发布生产时tomcat报错，发布失败。 哎，有时候真是说不清楚。在alpha和beta两个独立的测试环境测试通过的代码。准备上线，推到线上服务器的时候tomcat一直起不来，大量的报错。当时真是郁闷，完全没有方向。让运维重启了tomcat服务后也没用。后来开发上生产服务器追踪日志才发现是jar包冲突引起的tomcat大量报错无法无法加载。本身我们的java是通过maven来管理jar包的，理论上依赖应该关系没问题。最后定为到是我们使用的公司公用的soa框架的中的jar包和我们自己项目使用的jar包产生了冲突。只是测试环境走了大运走了一个合理的加载过程顺利发布。而在发布生生环境时发生冲突。只能根据公司框架来调整jar包。最终上线。 对接的基础服务发布，造成我方调用大量404.对接的基础服务紧急回滚。 事情很简单，我们对接的基础服务项目进行了技术改造并在测试环境测试通过后发布生产，因为生产环境的配置没有正确的修改。造成依赖方访问大量404，在发现问题后立马回滚到上个可用版本。 在问题发生后我也反思过，作为一个被大量调用的基础服务。在大的技术改造发布时确实有很大的风险。一但发生问题影响面就很大。本身是做负载均衡的，可能是因为实际需要，他们发布时一口气发布了全部的服务器，造成了服务不可用。其实可以让运维配合先把一台服务器拉出集群，发布后验证服务可用后再加入集群，之后再全部发布或是依次发布。 生产环境上的bug在测试环境难以重现。 在之前的一些线上问题的debug时经常发现一些问题在测试环境是无法重现的。换句活来说就是测试环境时，测试是通过的。但生产上却产生了bug。对于这种问题，相信对于每个测试人员来说都是很头疼的。我遇到的问题主要还是测试环境的架构和生产不相同。各种基础服务的配置、nginx的配置、多服务器负载均都会造成这中情况。被坑了不少次，但基于客观条件也只能劲量保证测试环境和生产环境架构相同，性能差些就差些。尽量能够把跟多的问题在测试过程中发现解决。 开发基线分支选择错误造成修复的bug再次产生。 在测试前端的某个版本中发现过一个隐藏较深的bug，开发修复后并发布后生产后。因为紧急增加了一个功能点，加班测试发布后了紧急版本后。突然发现线上部分用户使用时出现异常问题。debug后是发现是之前的修复的bug重现了。最终定位到是开发作为基线的开发分支选择错误。之后选择了正确的基线分支，bug是很快修复并重新发版。这次问题测试没有做全回归，回归测试覆盖不全是问题之一。但也从侧面表现出代码管理的重要性。修复的bug因为基线分支选择错误而产生bug，作为测试真的觉得很心累。之后也发现我们这边前端的分支管理混乱也要求合理管理分支。改进分支管理后，此类问题并未再现。 终 其实对于所有线上的bug，测试都无法推脱说这是技术难点我没有责任，虽然不少问题测试确实很难发现，尤其是一些线程安全问题，并发性能问题。在快速的业务迭代中，往往没有那么多富裕的时间给测试。不过问题还是测试不充分造成的。只能在快速的业务迭代中和测试周期中努力找到一个好的平衡点。我认为开发的单元测试自测，就能从底层排除掉很多测试难以发现的问题。测试更该去关注集成测试、容错性、兼容性测试和性能测试，而不是操心单一模块是否可用，遇到好的队友还是很重要的。","tags":"Blog","title":"2015年踩过的坑"},{"url":"https://chihiro.moe/posts/2015/AppiumIOS_1.html","text":"Appium的安装 要实现ios自动化前提是有一台Mac OS X操作系统的设备可以是正统的mac或是黑苹果。然后去 appium官网 下载appium服务端。osx上不推荐使用命令行安装，因为命令行看装会缺失appium inspector这个重要的元素定位工具。建议使用dmg安装包安装appium。然后在安装相应的appium client，我用的是python。 pip install appium-python-client 来完成client的安装。 iOS演示Demo的创建 先安装 xcode 。因为没有开发者证书所以只能用ios模拟器来演示，在这里不多说了。从 https://github.com/appium/sample-code 上下载appium的演示DEMO。 下载后进入 sample-code/apps/TestApp 目录下 执行 xcodebuild -sdk iphonesimulator 来编译所需的TestApp。 看到 BUILD SUCCEEDED TestApp就编译成功了。 在 sample-code-master/sample-code/apps/TestApp/build/release-iphonesimulator 目录下可以看到TestApp.app就是后面所需要使用的app。 Appium的配置 启动appium,点击 苹果 图标。 点击\"Choose\",选择之前编译生成的TestApp.app。并选择模拟设备\"iPhone6\"，系统版本为\"8.3\"。最后再次点击苹果图标确认设置。 点击放大镜按钮，来启动appium inspector控件元素识别工具。 此时inspector工具和iOS模拟器会同时启动。使用inspector可以很方便的查看控件的各类属性。 测试代码 # coding=utf8 import pytest import sys from appium import webdriver import random class TestClass ( object ): '''初始化weddriver链接''' @classmethod def setup_class ( self ): desired_caps = {} # appium版本 desired_caps [ 'appium-version' ] = '1.4.1' # 平台为iOS desired_caps [ 'platformName' ] = 'iOS' # 自启动被测应用 desired_caps [ 'autoLaunch' ] = 'true' # iOS系统版本 desired_caps [ 'platformVersion' ] = '8.3' # 设备为iPhone模拟器 desired_caps [ 'deviceName' ] = 'iPhone Simulator' # 需要上传至iPhone模拟器的被测应用 desired_caps [ 'app' ] = \"/Users/slade/Downloads/sample-code-master/sample-code/apps/TestApp/build/release-iphonesimulator/TestApp.app\" # 创建webdriver链接 self . wd = webdriver . Remote ( 'http://0.0.0.0:4723/wd/hub' , desired_caps ) self . wd . implicitly_wait ( 30 ) # 等待元素出现时间为30秒 '''验证TestApp求和功能''' def test_one ( self ): text_one = random . randint ( 1 , 100 ) # 创建1-100随机数 text_two = random . randint ( 1 , 100 ) # 创建1-100随机数 # 对第一个输入框输入第一个随机数 self . wd . find_element_by_name ( \"TextField1\" ) . send_keys ( text_one ) # 对第二个输入框输入第二个随机数 self . wd . find_element_by_name ( \"IntegerB\" ) . send_keys ( text_two ) # 点击求和按钮 self . wd . find_element_by_name ( \"ComputeSumButton\" ) . click () # 确定TestApp的求和计算结果 answer = self . wd . find_element_by_name ( \"Answer\" ) . text # 断言TestApp求和功能是否正确 assert int ( answer ) == text_one + text_two '''释放webdriver链接''' @classmethod def teardown_class ( self ): self . wd . quit () if __name__ == '__main__' : # 使用了单元测试框架pytest作为驱动 pytest . main ( sys . argv [ 0 ] + ' -s' ) 执行","tags":"Blog","title":"基于Appium实现IOS自动化测试。"},{"url":"https://chihiro.moe/posts/2015/AdbError.html","text":"在命令行输入adb shell后输出如下错误： adb server is out of date. killing... ADB server didn't ACK * failed to start daemon * error: unknown host service 使用 netstat -ano 查看哪个程序占用了 5037 端口 活动连接 协议 本地地址 外部地址 状态 PID TCP 0.0.0.0:49154 0.0.0.0:0 LISTENING 1080 TCP 0.0.0.0:49163 0.0.0.0:0 LISTENING 588 TCP 0.0.0.0:49167 0.0.0.0:0 LISTENING 604 TCP 127.0.0.1:5037 0.0.0.0:0 LISTENING 972 TCP 127.0.0.1:5037 127.0.0.1:49382 TIME_WAIT 0 TCP 127.0.0.1:5354 0.0.0.0:0 LISTENING 1868 TCP 127.0.0.1:5354 127.0.0.1:49155 ESTABLISHED 1868 TCP 127.0.0.1:5354 127.0.0.1:49156 ESTABLISHED 1868 记录下 PID ： TCP 127.0.0.1:5037 0.0.0.0:0 LISTENING 972 使用 taskkill /F /PID 972 杀死占用进程 /F 为强制进行 C:\\Users\\Slade>taskkill /F /PID 972 成功: 已终止 PID 为 972 的进程。","tags":"Blog","title":"Adb error: unknown host service 的解决方法"},{"url":"https://chihiro.moe/posts/2015/ClientMonitor.html","text":"起因 在测试一款通话类APP时，需要精确的统计客户端的流量消耗，电量消耗，CPU，内存等指标。磕磕碰碰的最终还是顺利的完成。在测试Android客户端的程中我一开始使用了Android SDK中的DDMS工具。 DDMS ddms位于\"D:\\adt-bundle-windows-x86\\sdk\\tools\"相似的目录下。运行ddms.bat 选择相应的应用进程例如：com.paobao.verytele 选择Network标签。可以看到该进程网络统计模块。 RX 为下行数据， TX 为上行数据。可选择统计数据的时间间隔（250ms），点击Start，就会开始采集数据。 因为DDMS使用起来并不是最符合我的需求，所以在这里只做简单的介绍，具体功能可以自己挖掘。 Emmagee 最终Android端我选择了网易开源项目 Emmagee 。支持中文，简单直观的选择应用开启统计，可设置采集间隔，并可以设置将报告发送至指定邮箱。报告为Excel格式，统计了APP的CPU、内存、流量、电量以及整体性能状态。 GT iOS端的性能监测工具找到了腾讯的项目 GT 。GT本身支持Android和iOS双平台，不过Android没有Emmagee更易用而已。iOS端是一个Framework包，必须嵌入APP工程。我让开发帮我集成进了APP中，同样可以统计APP的CPU、内存、流量、电量以及整体性能状态。","tags":"Blog","title":"移动客户端的性能监控。"},{"url":"https://chihiro.moe/posts/2015/Robotium.html","text":"package com . example . tt . test ; import com.robotium.solo.Solo ; import android.app.Activity ; import android.provider.UserDictionary.Words ; import android.test.ActivityInstrumentationTestCase2 ; import android.view.View ; @SuppressWarnings ( \"rawtypes\" ) public class TestVs extends ActivityInstrumentationTestCase2 { public Solo solo ; public Activity activity ; private static Class < ? > launchActivityClass ; private static String mainActiviy = \"com.paobao.verysercall.activity.LogoActivity\" ; private static String packageName = \"com.paobao.verysercall\" ; static { try { launchActivityClass = Class . forName ( mainActiviy ); } catch ( ClassNotFoundException e ){ throw new RuntimeException ( e ); } } @SuppressWarnings ({ \"unchecked\" , \"deprecation\" }) public TestVs () { super ( packageName , launchActivityClass ); } @Override protected void setUp () throws Exception { super . setUp (); this . activity = this . getActivity (); this . solo = new Solo ( getInstrumentation (), getActivity ()); } /* public void testCountryCode () throws Exception { solo . waitForText ( \"快速注册\" , 1 , 1000 ); solo . clickOnText ( \"国家和地区\" ); solo . clickOnText ( \"+30\" ); View view = null ; view = solo . getView ( \"android:id/action_bar\" ); solo . waitForView ( view ); boolean foundcode = solo . searchText ( \"+30\" ); assertTrue ( \"Country code is not found\" , foundcode ); solo . clickOnText ( \"+30\" ); solo . clickOnText ( \"+86\" ); view = solo . getView ( \"android:id/action_bar\" ); foundcode = solo . searchText ( \"+86\" ); assertTrue ( \"Country code is not found\" , foundcode ); } public void testLogInCaseOne () throws Exception { solo . waitForText ( \"下一步\" , 1 , 1 ); solo . clickOnEditText ( 0 ); solo . enterText ( 0 , \"73761000864\" ); solo . clickOnText ( \"下一步\" ); boolean findToast = solo . waitForText ( \"验证码发送失败！\" ); assertTrue ( \"手机号码格式错误，不该发送验证码。\" , findToast ); } public void testLogInCaseTwo () throws Exception { solo . waitForText ( \"下一步\" , 1 , 1 ); solo . clickOnEditText ( 0 ); solo . enterText ( 0 , \"13761000864\" ); solo . clickOnText ( \"下一步\" ); boolean findToast = solo . waitForText ( \"短信验证码发送成功\" ); assertTrue ( \"验证码发送失败\" , findToast ); boolean tmpText = solo . waitForText ( \"重新获取\" ); assertTrue ( tmpText ); solo . enterText ( 0 , \"1234\" ); solo . clickOnText ( \"下一步\" ); solo . waitForText ( \"通话记录\" ); } */ public void testMePage () throws Exception { solo . clickOnText ( \"我\" ); solo . waitForText ( \"我\" , 2 , 10 ); solo . waitForText ( \"剩余时间\" ); solo . waitForText ( \"用户\" ); solo . waitForText ( \"充值\" ); solo . waitForText ( \"面对面分享\" ); solo . waitForText ( \"关于VerySecret\" ); solo . waitForText ( \"退出当前账号\" ); } /* public void testLogOut () throws Exception { solo . clickOnButton ( \"我\" ); solo . clickOnButton ( \"退出当前帐号\" ); solo . clickOnButton ( \"确定\" ); solo . waitForText ( \"快速注册\" ); } */ @Override public void tearDown () throws Exception { try { this . solo . finishOpenedActivities (); } catch ( Throwable e ) { e . printStackTrace (); this . activity . finish (); super . tearDown (); } } }","tags":"Blog","title":"Robotium只有apk情况下的代码片段。"},{"url":"https://chihiro.moe/posts/2015/Jpype.html","text":"# coding:utf-8 # 使用jpype第三方库创建jvm使用java类 import jpype class MyDes : @staticmethod # 建立静态方法 def encode ( data ): # 读取系统jvm环境变量 jvmPath = jpype . getDefaultJVMPath () # 设置javaClass文件路径,可以是一个jar包 classpath = \"D: \\\\ git \\\\ VeryTeleTest \\\\ JavaServer\" jvmArg = \"-Djava.class.path=\" + classpath # 尝试开启jvm if not jpype . isJVMStarted (): jpype . startJVM ( jvmPath , jvmArg ) # 开启多线程支持 jpype . attachThreadToJVM () # 导入MyDes.class(DES加密模块) javaClass = jpype . JClass ( \"MyDes\" ) key1 = \"xxxxxxxxxxxxxxxxx\" # 秘钥1 key2 = \"xxxxxxxxxxxxxxxxx\" # 秘钥2 return javaClass . encode ( data , key1 , key2 ) # 使用MyDes.encode方法进行加密 @staticmethod # 建立静态方法 def decode ( data ): # 读取系统jvm环境变量 jvmPath = jpype . getDefaultJVMPath () # 设置javaClass文件路径,可以是一个jar包 classpath = \"D: \\\\ git \\\\ VeryTeleTest \\\\ JavaServer\" jvmArg = \"-Djava.class.path=\" + classpath # 尝试开启jvm if not jpype . isJVMStarted (): jpype . startJVM ( jvmPath , jvmArg ) # 开启多线程支持 jpype . attachThreadToJVM () # 导入MyDes.class(DES加密模块) javaClass = jpype . JClass ( \"MyDes\" ) key1 = \"xxxxxxxxxxxxxxxxx\" # 秘钥1 key2 = \"xxxxxxxxxxxxxxxxx\" # 秘钥2 return javaClass . decode ( data , key1 , key2 ) # 使用MyDes.decode方法进行加密","tags":"Blog","title":"Python调用Java的代码片段。"},{"url":"https://chihiro.moe/posts/2015/AutoStartOnLinux.html","text":"起因 最近因为机房经常停电，导致服务器频繁重启。每次都要手动去启动Redmine，我懒。所以把启动redmine的过程加入到了Linux系统启动过程中。 我使用的是CentOS 6.5 方法 1： 可能因发行版本不同rc.local的位置可能有不同 vim /etc/rc.local 在用户登录前执行，权限大。但无法使用\"~\"作为路劲，因为用户尚未登录，没有用户主目录。可以在/var/log/boot.log看到日志 方法 2： sudo vi /etc/profile 权限等同当前登录用户，有可能会有权限不足的问题。可以用'~'指定主目录。 实现Redmine随Linux系统自启动 编辑 /etc/rc.local 文件 vim /etc/rc.local 添加如下字段，因为启用Redmine必须先启动Mysql，所以把Mysql的启动也加了进去。 service mysqld start cd /var/www/redmine/ rails server Mongrel -d -e production -b 0.0.0.0 -p 3000 之后再断电就不用手工启动服务了。机房断电太坑了。","tags":"Blog","title":"让Redmine随Linux系统自动启动。"},{"url":"https://chihiro.moe/posts/2015/AppiumIOS.html","text":"# coding:utf-8 from appium import webdriver import time import os import time success = True desired_caps = {} desired_caps [ 'appium-version' ] = '1.0' desired_caps [ 'platformName' ] = 'iOS' desired_caps [ 'autoLaunch' ] = 'true' desired_caps [ 'platformVersion' ] = '8.1.2' desired_caps [ 'deviceName' ] = 'TestIphone6' desired_caps [ 'bundleId' ] = 'io.appium.TestApp' desired_caps [ 'udid' ] = 'd67350bd7dc62308dea8e919803441128cb11745' wd = webdriver . Remote ( 'http://0.0.0.0:4723/wd/hub' , desired_caps ) wd . implicitly_wait ( 10 ) def is_alert_present ( wd ): try : wd . switch_to_alert () . text return True except : return False try : wd . find_element_by_name ( \"TextField1\" ) . send_keys ( \"1\" ) wd . find_element_by_name ( \"IntegerB\" ) . send_keys ( \"2\" ) wd . find_element_by_name ( \"ComputeSumButton\" ) . click () time . sleep ( 5 ) finally : wd . quit () if not success : raise Exception ( \"Test failed.\" )","tags":"Blog","title":"Appium在iOS端实现的脚本片段。"},{"url":"https://chihiro.moe/posts/2015/InstallMongrel.html","text":"由于Redmine自带的Webrick Web服务器发布的问题，需要使用Mongrel组件来替换Webrick。Mongrel是一种快速的针对Ruby的Http服务器，专门为部署发布ROR应用而产生的。Mongrel相比Rails自带的纯Ruby服务器Webrick速度快很多并支持并发访问，有望成为Ruby的Tomcat. 替换其自带的服务器webrick为mongrel，方法： gem install mongrel rails 3.1以上执行: gem install mongrel –pre 修改redmine下gemfile，在gemfile中加入： gem 'mongrel' 如果安装的mongrel pre， 则gemfile中加: gem 'mongrel','~> 1.2.0.pre2' 删除gemfile.lock文件，重新执行: bundle install 执行 ruby script/rails server mongrel -e production","tags":"Blog","title":"Redmine使用Mongrel服务器。"},{"url":"https://chihiro.moe/posts/2015/InstallRedmine.html","text":"Install Redmine on Centos 65 dependencies packages These are the basic software packages for environment settings and utility tools to compile other packages in the next section. Copy the block command and execute in the Putty Windows : This is a long command line, copy all and implementation. yum -y install nano zip unzip libyaml-devel zlib-devel curl-devel openssl-devel httpd-devel apr-devel apr-util-devel mysql-devel gcc ruby-devel gcc-c++ make postgresql-devel ImageMagick-devel sqlite-devel perl-LDAP mod_perl perl-Digest-SHA Install Apache and MySQL Apache is a server application for communicating over the HTTP protocol. Apache runs on operating systems such as Unix, Linux, Microsoft Windows, and other operating systems. Apache play an important role in the development of the internet and the world wide web. MySQL is the database management free open source most popular on the world, MySQL has high speed, stability and ease of use, portability, operating on multiple operating systems offer a large system is very powerful utility functions. With the speed and high security, MySQL is well suited for applications that access databases on the internet. Use the following command to install : yum -y install httpd mysql mysql-server Allow start services when OS boot : chkconfig httpd onchkconfig mysqld onservice httpd startservice mysqld start Set the password for MySQL /usr/bin/mysql_secure_installation Because we not have a password for the root account so you press Enter to skip. Enter current password for root (enter for none): Select Yes to set the password for the MySQL root account. Set root password? [Y/n] y Enter and confirm your password, remove the anonymous user, select Yes Remove anonymous users? [Y/n] y Allow remote login to MySQL as root account, select No. Disallow root login remotely? [Y/n] n Delete the test database, select Yes Remove test database and access to it? [Y/n] y Reload privilege tables, select Yes Reload privilege tables now? [Y/n] y Turn off SELinux SELinux is a security feature advanced for Linux operating system, when installing the system you need to turn off this feature to get the process done smoothly, after successful you can turn on back if you want. nano /etc/selinux/config Change the file content : SELINUX=disabled Press CTRL + O to save the file and press CTRL + X to exit. Set up the Hostname By default when installing a new OS Centos not set the hostname, so we need to setting with the command : nano /etc/hosts Add your domain name or host name that you set on both the command line, save the file and exit, the server name will be changed when restarting. Configuring the Firewall We do not want to turn off the firewall because it's quite important, so you need to add rules to allow port 80 for HTTP and port 443 for HTTPS. In the Centos OS, you can configuration firewall by editing files iptables and ip6tables. nano /etc/sysconfig/iptables Press Enter to create a new line after the line of port 22, copy the following two commands and right click on the window to the Paste command. -A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 443 -j ACCEPT Press CTRL + O to save the file and press CTRL + X to exit. The same applies for IP6 firewall : nano /etc/sysconfig/ip6tables Add these lines to the file. -A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 443 -j ACCEPT After you finish editing both files, run the commands to apply the new rules for firewall. /etc/init.d/iptables restart/etc/init.d/ip6tables restart Allow turn on the firewall when reboot the operating system. chkconfig iptables onchkconfig ip6tables on Finally, we need to restart the system to apply the changes to the SELinux and Hostname. reboot Install Ruby Ruby is a object-oriented programming language, capable of reflection. Syntax inherited from Ada and Perl with object-oriented features of Smalltalk, and also share some features with Python, Lisp, Dylan and CLU, Ruby is a single phase interpreter. Ruby provides programming patterns, including functional programming, object-oriented, imperative, reflective, it uses dynamic variable and automatic memory management. Install Ruby interpreter with version management program RVM. \\curl -L https://get.rvm.io | bash After successful, we will launch RVM source /etc/profile.d/rvm.sh The following command will list the versions of Ruby to install : rvm list known We choose the stable version [ruby-] 1.9.3 [-p545], and execute the following command : rvm install 1.9.3 The installation process is pretty long time, but you do not need any intervention, after successful, you check with the following command : ruby -v Install Rubygems Rubygems is a Ruby's packages management program, very popular in applications written by Ruby language and the Ruby On Rails framework. yum -y install rubygems Install Passenger The full name of the Passenger is Phusion Passenger, known as mod_rails or mod_rack, it is a web application intergrate with Apache and it can operate as a standalone web server support for the Ruby On Rails applications. Execute the following commands : gem install passengerpassenger-install-apache2-module After completed, we copy a notification block in the window to create the configuration file in the next steps (select block notification and press C to copy). LoadModule passenger_module /usr/local/rvm/gems/ruby-1.9.3-p545/gems/passenger-4.0.37/buildout/apache2/mod_passenger.so PassengerRoot /usr/local/rvm/gems/ruby- 1.9.3-p545/gems/passenger- 4.0.37 PassengerDefaultRuby /usr/local/rvm/gems/ruby- 1.9.3-p545/wrappers/ruby Create a new virtual host file for Passenger : nano /etc/httpd/conf.d/passenger.conf Paste the command blocks into the empty file and save it, then restart the Apache service. service httpd restart Create Database for Redmine Use MySQLAdmin to create an empty database for Redmine, saved password to fill in the configuration file in the next steps. mysql --user=root --password=root_password_mysqlcreate database redmine_db character set utf8;create user 'redmine_admin'@'localhost' identified by 'your_new_password';grant all privileges on redmine_db.* to 'redmine_admin'@'localhost';quit; Install Redmine Redmine is a main program of the project management system, we will download and install the program from the website of Redmine. Download Redmine version 2.5.x to directory \"/var/www\" on the Centos OS. cd /var/wwwwget http://www.redmine.org/releases/redmine-2.5.0.tar.gz Extract the folder and rename directory tar xvfz redmine-2.5.0.tar.gzmv redmine-2.5.0 redminerm -rf redmine-2.5.0.tar.gz Configuring the Database The next, we need to configure the database was created from the above steps. cd /var/www/redmine/configcp database.yml.example database.ymlnano database.yml Enter name for database, enter username and password of the database. Press CTRL + O to save the file and CTRL + X to exit. Setting up Rails Install the package library support for Rails using the Bundle. cd /var/www/redminegem install bundlerbundle installrake generate_secret_token The next, we create the database table for the Redmine application. RAILS_ENV=production rake db:migrateRAILS_ENV=production rake redmine:load_default_data Activate FCGI cd /var/www/redmine/publicmkdir plugin_assetscp dispatch.fcgi.example dispatch.fcgicp htaccess.fcgi.example .htaccess Setting up Apache and FastCGI cd / var / www / rpm -- import https : // fedoraproject . org / static / 060 8 B895 . txtwget http : // dl . fedoraproject . org / pub / epel / 6 / x86_64 / epel - release - 6 - 8. noarch . rpmrpm - ivh epel - release - 6 - 8. noarch . rpmyum - y install mod_fcgidrm - rf epel - release - 6 - 8. noarch . rpm Creating Files Directory This directory contains data files generated during the operation of Redmine as document or image file, we create a new directory in the \"/opt\". mkdir -p /opt/redmine/fileschown -R apache:apache /opt/redminecd /var/www/redmine/configcp configuration.yml.example configuration.ymlnano configuration.yml Enter the directory path containing the data files you just created in the previous step into the line \"attachments_storage_path\". Note: You must add a space at the begin of the path \"/opt/redmine/files\" after character \":\" Configuring Email Another very important function of Redmine is using email to notify members when the contents of each project changes, Redmine can use many different methods to send email that is Sendmail, SMTP, GMail ... To configure the email we will edit the configuration file. nano /var/www/redmine/config/configuration.yml The simplest is you use features of the default SendMail in the Centos OS by settings : email_delivery:delivery_method: :sendmail Note : Do not use the Tab key to indent when editing the configuration file, you need to use the space bar on the keyboard. If you use GMail's SMTP, you need to register an email account with the login methods used password normal and disable two-step authentication by smart phone. Enter your Gmail account as below : email_delivery : delivery_method : : smtp smtp_settings : enable_starttls_auto : true address : \"smtp.gmail.com\" port : 587 domain : \"smtp.gmail.com\" authentication : : plain user_name : \"your_email@gmail.com\" password : \"your_password\" Save the file configuration and exit. Create Virtual Host for Redmine Create an Apache configuration file for the Redmine application at the port 80. nano /etc/httpd/conf.d/redmine.conf Copy the text below and paste into the editor window, note the information to change your domain name. 80> ServerName your_domain ServerAdmin your_domain @domain.com DocumentRoot /var/www/redmine/public/ ErrorLog logs/redmine_error_log \"/var/www/redmine/public/\"> Options Indexes ExecCGI FollowSymLinks Order allow,deny Allow from all AllowOverride all Save the file configuration and exit. Running Redmine Before execute Redmine in the first time, we must permission for the directory installed Redmine and restart Apache service. cd /var/wwwchown -R apache:apache redminechmod -R 755 redmineservice httpd restart Redmine will run at the following address URL : http://your-domain Login to system with an administrator account : admin / admin You can change your password after successful login. We can see Redmine has running but very primitive, in the next steps we will install the support plugins and customized Redmine to use professional. Install Subversion Subversion, also known as SVN, it is a version management system is very popular and easy to use, most programmers can use it competently. We need to create a folder to store data for Redmine, the following command creates a directory and permissions for the Apache service. mkdir -p /opt/repositories/svnchown -R apache:apache /opt/repositories/chmod 0755 /opt/repositories The following command install Subversion and the packages : yum install mod_dav_svn subversion subversion-ruby The next, we will create a directory and copy the file called \"Redmine.pm\", it responsible for interface data repository with Redmine and it is written by Perl language programming. mkdir /usr/lib64/perl5/vendor_perl/Apacheln -s /var/www/redmine/extra/svn/Redmine.pm /usr/lib64/perl5/vendor_perl/Apache/Redmine.pm Note : If you are using 32 bit Centos, change the path \"/usr/lib64\" to \"/usr/lib\" After installation is complete, from the Redmine application, go to the page Administration> Settings> Repositories to check the results. To support the authentication and access to data repository for each member, we need to create a virtual host for the Apache service can access Redmine database. nano /etc/httpd/conf.d/subversion.conf Add the following lines to the end and still retain the old contents of the file : PerlLoadModule Apache::Redmine DAV svn SVNParentPath \"/opt/repositories/svn\" SVNListParentPath on Order deny , allow Deny from all Satisfy any LimitXMLRequestBody 0 SVNPathAuthz off PerlAccessHandler Apache :: Authn :: Redmine :: access_handler PerlAuthenHandler Apache :: Authn :: Redmine :: authen_handler AuthType Basic AuthName \"Subversion Repository\" Require valid-user RedmineDSN \"DBI:mysql:database=redmine_db;host=localhost:3306\" RedmineDbUser \"redmine_admin\" RedmineDbPass \"your_password_database_redmine\" Note : You need to change the password in the \"RedmineDbPass\" to correct the database password of Redmine. At this point, we have finished the basic settings for Redmine. Thank you!","tags":"Blog","title":"Install Redmine on Centos."},{"url":"https://chihiro.moe/posts/2015/NoCpUseCat.html","text":"在Android shell 下可能并没有安装cp命令，一般都不会安装。需要的可以自己安装busybox工具。在紧急的情况下可以使用cat命令来代替cp。 adb shell cd /mnt/sdcard cat xxx.apk >> yyy.apk # 将/mnt/sdcard目录下的xxx.apk复制为yyy.apk Busybox 是一个集成了一百多个最常用linux命令和工具的软件。需要选择适合你手机cpu的版本来安装。查看手机CPU信息，根据Processor来选择安装版本。 cat /proc/cpuinfo Processor : ARMv7 Processor rev 2 (v7l) ... 将busybox复制到 /system/xbin 目录下，并修改文件权限，使其可执行。 cat busybox-armv7l >> /system/xbin/busybox chmod 775 busybox busybox --install 大功告成，现在就可以在Android shell下使用常用的linux命令了。","tags":"Blog","title":"在Android shell下无法使用cp命令的解决方案。"},{"url":"https://chihiro.moe/posts/2015/ReadOnlyFileSystem.html","text":"问题 当往android的/system目录下拷贝文件时一般是会报\"Read-only file system\"。因为/system目录默认是只读的。 解决方法 首先是获取手机的 root权限 后 adb shell su # 切换成ROOT用户 mount -o rw,remount /system #将/system目录设置为读写模式 mount -o ro,remount /system #将/system目录设置为只读模式","tags":"Blog","title":"解决Android复制文件报\"Read-only file system\"的问题。"},{"url":"https://chihiro.moe/posts/2015/RedmineEmail.html","text":"当Redmine配置邮件后，会发现提交Bug等操作响应缓慢。是因为Redmine在确定邮件发送完成后才会返回提交成功的页面。设置成异步发送邮件，操作流程就流畅了。 vim /var/www/redmine/config/configuration.yml delivery_method：async_smtp or delivery_method : async_sendmail","tags":"Blog","title":"Redmine异步发送邮件。"},{"url":"https://chihiro.moe/posts/2015/adbmore.html","text":"常用命令 adb devices # 查看已连接PC的终端 adb shell # 连接终端 adb -s [devicesId] shell # 多台设备根据设备号连接终端 adb push xxx.apk /mnt/sdcard/xxx.apk # 将本地文件传送至手机 adb pull /mnt/sdcard/xxx.apk xxx.apk # 将手机中的文件传送至本地","tags":"Blog","title":"Adb常用命令。"},{"url":"https://chihiro.moe/posts/2015/BlogStart.html","text":"Blog前期的搭建终于完成。可以开始装逼之旅了，作为一个IT人没有自己的博客总觉得有点low。建立博客的初衷是为了学习和记录，逼格的提升是次要的（xxx：骗谁啊！？）。 我最终选择了 Pelican + github 的组合。 之所以选择了Pelican没有选择Jekyll因为工作本身用 Python 较多,非常喜欢Python的语法结构，爱屋及乌。 Pelican选择了 elegant 这个皮肤，功能非常的齐全。可惜Pelican自带的站内搜索插件调试了多次都失败了。最后选用了 Swiftype 作为站内搜索。从网上搞了段代码实现了 返回顶部 的功能。使用Cygwin解决了Windows系统下的使用无法使用make的问题。 在这个过程中接触了html、css、JavaScript、模板语法、markdown语法、git、github。","tags":"Blog","title":"Blog Start!"}]};